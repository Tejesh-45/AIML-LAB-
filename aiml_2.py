# -*- coding: utf-8 -*-
"""AIML-2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eTsbvjLusWaoxOB0aoCR7SgngBXiEBPq
"""

from queue import Queue

graph = {0: [1, 3], 1: [0, 2, 3], 2: [4, 1, 5], 3: [4, 0, 1], 4: [2, 3, 5], 5: [4, 2], 6: []}
print("The adjacency list representing the graph is:")
print(graph)

def bfs(graph, source):
    queue = [source]
    visited = set([source])

    while queue:
        vertex = queue.pop(0)
        print(vertex, end="-->")

        for neighbor in graph[vertex]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

print("\nBFS traversal of graph with source 0 is:")
bfs(graph, 0)

graph1 = {
    'A' : ['B','S'],
    'B' : ['A'],
    'C' : ['D','E','F','S'],
    'D' : ['C'],
    'E' : ['C','H'],
    'F' : ['C','G'],
    'G' : ['F','S'],
    'H' : ['E','G'],
    'S' : ['A','C','G']
}

def dfs(graph, node, visited):
    if node not in visited:
        visited.append(node)
        for k in graph[node]:
            dfs(graph,k, visited)
    return visited

visited = dfs(graph1,'D', [])
print(visited)

import numpy as np
import time

def best_solution(state):
    best_path = []
    count = len(state) - 1
    while count != -1:
        best_path.insert(0, state[count]['puzzle'])
        count = state[count]['parent']
    return best_path

def misplaced_tiles(puzzle, goal):
    return np.sum(puzzle != goal) - 1

def coordinates(puzzle):
    return np.argsort(puzzle)

def evaluate_misplaced(puzzle, goal):
    steps = [('up', [0, 1, 2], -3), ('down', [6, 7, 8], 3),
             ('left', [0, 3, 6], -1), ('right', [2, 5, 8], 1)]

    state = [{'puzzle': puzzle, 'parent': -1, 'gn': 0, 'hn': misplaced_tiles(coordinates(puzzle), coordinates(goal))}]
    priority = [(0, state[0]['hn'])]

    while priority:
        priority.sort(key=lambda x: x[1])
        position, _ = priority.pop(0)
        puzzle = np.array(state[position]['puzzle'])

        blank = int(np.where(puzzle == 0)[0])

        for move, positions, head in steps:
            if blank not in positions:
                new_puzzle = puzzle.copy()
                new_puzzle[blank], new_puzzle[blank + head] = new_puzzle[blank + head], new_puzzle[blank]

                if not any(np.array_equal(new_puzzle, s['puzzle']) for s in state):
                    new_state = {'puzzle': new_puzzle.tolist(), 'parent': position, 'gn': state[position]['gn'] + 1,
                                 'hn': misplaced_tiles(coordinates(new_puzzle), coordinates(goal))}
                    state.append(new_state)
                    fn = new_state['gn'] + new_state['hn']
                    priority.append((len(state) - 1, fn))

                    if np.array_equal(new_puzzle, goal):
                        print("The 8-puzzle is solvable")
                        return state

    print("The 8-puzzle is unsolvable")
    return state

puzzle = [2, 8, 3, 7, 1, 4, 0, 6, 5]
goal = [1, 2, 3, 8, 0, 4, 7, 6, 5]

state = evaluate_misplaced(puzzle, goal)
best_path = best_solution(state)

for step in best_path:
    print(np.array(step).reshape(3, 3))
print(f"\nSteps to reach goal: {len(best_path) - 1}")